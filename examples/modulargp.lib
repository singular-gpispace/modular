      ///////////////////////////////////////
       version="version modulargp.lib 0.1 May_2022 ";
       category="Algebraic geometry";
       info="
       LIBRARY: modulargp.lib  demo procedures for modular pattern

       OVERVIEW:
           This library contains SINGULAR procedures to demonstrate the
           modular pattern of the Singular/GPI-Space framework.
           The newstruct types token  must be defined.

       PROCEDURES:
       stdmodp(token,token)               computes a standard basis
                                           modulo p
       liftt(token, token)                lift the two modular result
       farey(token)                       
       compatible(token, token)           
       compare(token, token)
";
        
        proc genNextPrime(token input, int p)
        {
            LIB "modstd.lib";
            def I = input.data[1];
            token t;
            token tok;
            int temp = p;
            int lastt;
            while( size(t.data) < 96 )
            {
               
                if(temp == 2)
                {
                    if (size(t.data) == 0 ) {ERROR("no more primes");}
                    else {break;} 
                }
                temp = prime(temp-1);
                if (primeTest(I,temp))
                {   
                    t.fieldnames[size(t.fieldnames)+1] = "prime token";
                    tok.fieldnames = list("integer");
                    tok.data[1] = temp;
                    t.data[size(t.data)+1] = tok;
                }
            }
            t.fieldnames[size(t.fieldnames)+1] = "last_prime";
            lastt = tok.data[1];  
            t.data[size(t.data) +1]  = lastt;
            return(t);
        }

       proc hashlead(ideal I)
       {
            if(size(I) == 0)
            {
                return(string(-1));
            }
            int i;
            int j;
            string hash="";
            intvec v;
            ideal J = lead(I);
            for(i=1; i<=size(J); i++)
            {
                v = leadexp(J[i]);
                for(j=1; j<=size(v); j++)
                {
                 hash = hash +  string(v[j]);
                }
            }
            return(hash);

        }

        proc stdmodp (token input, token in_prime)
            "USAGE: stdmodp(input, in_prime); input token
            RETURN: an token output containing a standard basis 
                    output.generators of the ideal input.generators in a ring
                    with prescribed characteristic input.modulus
            NOTE: The types token are defined . This procedure is 
                    intended to be called as a transition procedure inside the
                    worker process (that is, the "inner" instances of SINGULAR).
"
        {
            def br = basering;
            int p = in_prime.data[1];
            def I = input.data[1];
            def lbr = ringlist(br);
            lbr[1] = p;
            def rp = ring(lbr);
            setring rp;
            def I = imap(br,I);
            option(redSB);
            def J = std(I);
            setring br;  
            def J = fetch(rp,J);
            token output;
            output.fieldnames = list("generators","modulus",
                                    "numberofprimes","leadmon");
            output.data[1] = J;
            output.data[2] = bigint(p);
            output.data[3] = int(1);
            output.data[4] = hashlead(J);
            return(output);
       }

       proc liftt (token left, token right)
       "USAGE: liftt(left, right); input token
       RETURN: an token output containing a lift of the two tokens left and right.
       NOTE  : The types token are defined . This procedure is intended to
               be called as a transition procedure inside the worker process
               (that is, the "inner" instances of SINGULAR).
"          
       {
           def J = right.data[1];
           bigint p = right.data[2];
           int n = right.data[3];
           def I = left.data[1];
           bigint q = left.data[2];
           int m =  left.data[3];
           def IJ = chinrem(list(I,J),list(q,p));
           token output;
           output.fieldnames =
           list("generators","modulus","numberofprimes");
           output.data[1] = IJ;
           output.data[2] = p*q;    
           output.data[3] = n+m;
           return(output);
       }

        proc fareyy (token liftedres)
       "USAGE: fareyy(liftedres); 
       RETURN: a token  containing a farey lift of the data in the token liftedres.
"          
        {
            def I = liftedres.data[1];
            bigint N = liftedres.data[2];
            int n = system("--cpus");
            system("--cpus",1);
            def J = farey(I,N);
            system("--cpus",n);
            token t;
            t.fieldnames = list("farey_lift","Nb_generators");
            t.data[1] = J;
            t.data[2] = size(J);
            return(t);
        }


         proc compatible (token fareylift, token testToken)
       "USAGE: compatible(token, token); 
       RETURN: Test if any coefficient occuring in the data of fareylift is divisible by the characteristic p of the data in the testToken."

        {
            LIB "modstd.lib";
            bigint p = testToken.data[2];
            def I = fareylift.data[1];
            int testt = primeTest(fareylift.data[1],p);
            token t;
            t.fieldnames = list("test_result");
            t.data[1] = testt;
            return(t);
        }

         proc compare (token fareylift, token testToken)
       "USAGE: compare(token, token); 
       RETURN: Reduce the data of the farey lift modulo the characteristic of the testToken and check if they are equal."

       {
            def J = fareylift.data[1];
            def I = testToken.data[1];
            bigint p = testToken.data[2];
            def br = basering;
            def lbr = ringlist(br);
            lbr[1] = int(p);
            def rp = ring(lbr);
            setring rp;
            def I = fetch(br,I);
            def J = fetch(br,J);
            attrib(J, "isSB", 1);
            attrib(I, "isSB", 1);
            token t;
            t.fieldnames=list("test result");
            t.data[1] = int(0);
            /* test if I is in J */
            int i;
            for (i = ncols(I); i > 0; i--)
            {
                if (reduce(I[i], J[i], 1) != 0)
                {
                    setring(br);
                    return(t);
                }
            }
            /* test if J is in I 
            for (i = ncols(J); i > 0; i--)
            {
                if (reduce(J[i], I, 1) != 0) { setring(br); return(t); }
            }*/
            setring br;
            t.data[1] = int(1);
            return(t);
       }


        proc splitt(token in)
        {
            ideal I = in.data[1];
            bigint p = in.data[2];
            token out;
            token t;
            int i;
            int n = size(I);
            int m = n div 1;
            int final = n mod 1;
            for(i=1; i<=m; i++)
            {
                t.fieldnames = list("generator","modulus");
                t.data[1] = ideal(I[((i-1)*1+1) .. (i*1)]);
                t.data[2] = p;
                out.fieldnames[i] = "generator";
                out.data[i] = t;
            }
            if (final != 0)
            {
                t.fieldnames = list("generator","modulus");
                t.data[1] = ideal(I[(1*m+1) .. (1*m+final)]);
                t.data[2] = p;
                out.fieldnames[m+1] = "generator";
                out.data[m+1] = t;
            }
            //t.fieldnames = list("total_number_generator");
            //t.data[1] = n;
            out.fieldnames[size(out.fieldnames)+1] = "total_number_generator";
            out.data[size(out.data) + 1] = n;
            return(out);
        }

        proc appendGenerator(token left, token right)
        {
            LIB "general.lib";
            def I = right.data[1];
            def J = left.data[1];
            ideal K = I,J;
            K = sort(K)[1];
            token out;
            out.fieldnames[1] = "generator";
            out.data[1] = K;
            return(out);
        }




    /*proc reconstest(token lifted_res, token test_token)
       "USAGE: reconst(lifted_res, mod_res2); lifted_res token
        RETURN: an list  containing a token of the Farey lift and a 
           boolean of the stability test
        NOTE: The types token are defined . This procedure is 
              intended to be called as a transition procedure inside
              the worker process (that is, the "inner" instances of
              SINGULAR).
"          
    {     
        ideal I = test_token.data[1];
        bigint p = test_token.data[2];
        ideal J = lifted_res.data[1];
        bigint q = lifted_res.data[2]; 
        ideal K = chinrem(list(I,J),list(p,q));
        int n = system("--cpus");
        system("--cpus",1);
        ideal Jf = farey(J,q);
        ideal Kf = farey(K,p*q);
        system("--cpus",n);
        token t;
        int i=0;
        int testt = 0;
        t.fieldnames = list("generators","test");
        t.data[1] = Jf;
        if  ( size(Jf) == size(Kf) )
        {
            testt=1;
            for(i=1;i<=size(Jf);i++)
            {
                if ((Jf[i]-Kf[i]) !=0)
                {
                    testt = 0;
                    break;
                }
            }
        }
        
        t.data[2] = testt;
        return(t);
    }*/

