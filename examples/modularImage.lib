      ///////////////////////////////////////
       version="version modulargp.lib 0.1 May_2022 ";
       category="Algebraic geometry";
       info="
       LIBRARY: modularImage.lib  demo procedures for modular pattern

       OVERVIEW:
           This library contains SINGULAR procedures to demonstrate the
           modular pattern of the Singular/GPI-Space framework.
           The newstruct types token  must be defined.

        PROCEDURES:
        stdmodp(token,token)               computes a standard basis
                                           modulo p
        ImageRationalMap(token, token)     compute the image of a rational map
        liftt(token, token)                lift the two modular result
        reconstest(token, token)           farey lift and stability test
";

LIB "elim.lib";

       proc hashlead(ideal I)
       {
           int i;
           int j;
           string hash="";
           intvec v;
           ideal J = lead(I);
           for(i=1; i<=size(J); i++)
           {
             v = leadexp(J[i]);
             for(j=1; j<=size(v); j++)
             {
               hash = hash +  string(v[j]);
             }
           }
           return(hash);

        }

       proc stdmodp (token input, token in_prime)
       "USAGE: stdmodp(input, in_prime); input token
           RETURN: an token output containing a standard basis 
           output.generators of the ideal input.generators in a ring
           with prescribed characteristic input.modulus
           NOTE: The types token are defined . This procedure is 
           intended to be called as a transition procedure inside the
           worker process (that is, the "inner" instances of SINGULAR).
"
       {
       def br = basering;
       int p = in_prime.data[1];
       def I = input.data[1];
       def lbr = ringlist(br);
       lbr[1] = p;
       def rp = ring(lbr);
       setring rp;
       def I = imap(br,I);
       option(redSB);
       def J = std(I);
       setring br;  
       ideal J = fetch(rp,J);
       token output;
       output.fieldnames = list("generators","modulus",
                                    "numberofprimes","leadmon");
       output.data[1] = J;
       output.data[2] = bigint(p);
       output.data[3] = int(1);
       output.data[4] = hashlead(J);
       return(output);
       }

       proc ImageRationalMap(token input, token in_prime)
       {
        def phi = input.data[1];
        int p = in_prime.data[1];
        def I = input.data[2];
        def br = basering;
        def lbr = ringlist(br);
        lbr[1] = p;
        def rp = ring(lbr);
        setring rp;
        def I = imap(br,I);
        def phi = imap(br,phi);
        option(redSB);
        //def RTarget = ImageMap(phi,I);

        int n = nvars(br);
        // number of variables of target polynomial ring, that is 7
        int m = size(phi);
        /*phi: P^(n-1) --> P^(m-1)*/
        // make a polynomial ring for the graph with variables
        // x(1)..x(n) and  y(1)..y(m)
        def R = basering;
        list rl = ringlist(R);
        int k;
        for(k = 1; k <= n; k++)
        {
            rl[2][k] = "x("+string(k)+")";
        }
        for(k = 1; k <= m; k++)
        {
            rl[2][k+n] = "y("+string(k)+")";
        }
        rl[3]= list(list("dp",1:n),list("dp",1:m),list("C",0));
        def Rbig0 = ring(rl);
        setring Rbig0;
        // fetch I and phi to that new ring
        ideal phi = fetch(R,phi);
        ideal I = fetch(R,I);
        // ideal of the graph;
        ideal mi = maxideal(1);
        ideal xv = mi[1..n];
        ideal yv  = mi[n+1..n+m];
        matrix HM[2][m] = concat(transpose(yv),transpose(phi));
        ideal J = sat(I+minor(HM,2),phi)[1];
        ideal graph = sat(J,xv)[1];
        //Extracting the image from the graph
        for(k = 1; k <= n; k++)
        {
            graph = subst(graph,xv[k],0);
        }
        graph = compress(graph);
        //create the target ring
        setring R;
        list rl2 = rl[2];
        rl[1] = 0;
        rl[2] = list(rl2[n+1..n+m]);
        rl[3]= list(list("dp",1:m),list("C",0));
        def Rtarget = ring(rl);
        setring Rtarget;
        ideal image = imap(Rbig0,graph);
        //write the result in a token
        token output;
        output.fieldnames = list("generators image","modulus","numberofprimes","leadmon");
        output.data[1] = image;
        output.data[2] = bigint(p);
        output.data[3] = int(1);
        output.data[4] = hashlead(image);
        return(output);
       }

       proc liftt (token left, token right)
       "USAGE: liftt(left, right); input token
       RETURN: an token output containing a lift of the two tokens left and
           right.
       NOTE: The types token are defined . This procedure is intended to
           be called as a transition procedure inside the worker process
           (that is, the "inner" instances of SINGULAR).
"          
       {
           def J = right.data[1];
           bigint p = right.data[2];
           int n = right.data[3];
           def I = left.data[1];
           bigint q = left.data[2];
           int m =  left.data[3];
           def IJ = chinrem(list(I,J),list(q,p));
           token output;
           output.fieldnames =
           list("generators","modulus","numberofprimes");
           output.data[1] = IJ;
           output.data[2] = p*q;
           output.data[3] = n+m;
           return(output);
       }

       proc reconstest(token lifted_res, token mod_res2)
       "USAGE: reconst(lifted_res, mod_res2); lifted_res token
           RETURN: an list  containing a token of the Farey lift and a 
           boolean of the stability test
           NOTE: The types token are defined . This procedure is 
           intended to be called as a transition procedure inside
           the worker process (that is, the "inner" instances of
           SINGULAR).
"          
       {     
       // def S = mod_res_2.r_data;
       //   setring S;
       ideal I = mod_res2.data[1];
       bigint p = mod_res2.data[2];
       //def R = lifted_res.r_data;
       //setring R;
       ideal J = lifted_res.data[1];
       bigint q = lifted_res.data[2];
       //setring S;
       //ideal J = fetch(R,J);
       ideal K = chinrem(list(I,J),list(p,q));
       ideal Jf = farey(J,q);
      ideal Kf = farey(K,p*q);
      //attrib(Jf,"isSB",1);
      //attrib(Kf,"isSB",1);
       token t;
       int i;
       int testt = 0;
       t.fieldnames = list("generators","test");
           t.data[1] = Jf;
       if  ( size(Jf) == size(Kf) )
      {
         testt=1;
      for(i=1;i<=size(Jf);i++)
      {
       if ((Jf[i]-Kf[i]) !=0)
      {
         testt = 0;
        break;
       }
       }
           }
       t.data[2] = testt;
       return(t);
       }

