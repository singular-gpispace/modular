random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
random(1,10^9);
exit
;
newstruct("modular_data", "ring over, ideal data, bigint modulus, int nbprime");
ring r;
ideal I=x+2;
modular_data a;
a.over=basering;
a.data = I;
a.modulus =1;
a.nbprime=1;
link l = "ssi:w testfile.ssi";
write(l,a);
close(l);
link t = "ssi:r testfile.ssi";
read(t);
read(t);
exit;
newstruct("modular_data", "ring over, ideal data, bigint modulus, int nbprime");
ring r;
idea I = (x+2)^100;
ideal I = (x+2)^100;
;
i:
;
I;
ideal I = (x+2)^300;
I;
modular_data a;
a.over=basering;
a.data = I;
a.modulus =1;
a.nbprime=1;
link l = "ssi:w testfile.ssi";
write(l,a);
close(l);
exit;
ls
;
link l = "ssi:r testfile.ssi";
read(l);
l = read(l);
l = read(l);
def t  = read(l);
t;
read(l);
t;
read(l);
read(l);
read(l);
read(l);
read(l);
read(l);
read(l);
read(l);
read(l);
read(l);
read(l);
read(l);
read(l);
read(l);
exit;
ring r = 0,(x,y),dp;
ideal I = 3x2+x+1, x3+3x2+1;
I;
link l = "ssi:w input.ssi";
write(l, I);
close(l);
link l = "ssi:w prime.ssi";
int i = 3;
write(l, i);
close(l);
exit;
LIB "random.lib";
ring r = 0,(x,y,z),dp;
ideal I = randomid(maxideal(30),30);
link l = "ssi:w input.ssi";
write(l,I);
close(l);
exit;
prime(1000000);
prime(100000000);
prime(11341235454542);
prime(1134123545452);
prime(113412354545);
prime(11341235454);
prime(1134123545);
prime(1134123545);
int i = prime(1134123545);
link l = "ssi:w prime.ssi";
write(l,i);
close(l);
exit;
LIB "random.lib";
ring r = 0, (x,y,z),dp;
ring r = 0, (x,y,z),lp;
ideal I =randomid(maxideal(30),30);
c
exit;
LIB "random.lib";
ring r = 0,(x,y,z),lp;
ideal I =randomid(maxideal(30),30)
;
ideal I =randomid(maxideal(100),1000);
link l = "ssi:w input.ssi";
write(l,I);
close(l);
exit;
LIB "random.lib";
ring r=0,(x,y,z),lp;
ideal I = randomid(maxideal(30),30)
;
ideal I = randomid(maxideal(50),50);
link l = "ssi:w input.ssi";
write(l,I);
close(l);
exit;
LIB "random.lib";
ring r = 0 ,(x,y,z),dp;
ideal I = randomid(maxideal(30),30);
link l = "ssi:w input.ssi";
write(l,I);
close(l);
exit;
link l = "ssi:w test.ssi";
exit ;
link l = "ssi:w input.ssi";
newstruct("token", "list fieldnames, list data");
token t;
ring r=0,(x,y),dp;
ideal I = xy7 +7x+1, y2+2;
t.fieldnames = list("generators");
t.data = list(I);
write(l,t);
close(l);
exit;
newstruct("token", "list fieldnames, list data");
link l = "ssi:w prime.ssi";
bigint i = 7;
token t;
t.fieldnames = list("prime");
t.data = list(i);
write(l,t);
close(l);
exit;
void call_singular (std::string const& command)
{
  int err = iiAllStart
    (NULL, const_cast<char*> (command.c_str()), BT_proc, 0);
  if (err)
  {
    errorreported = 0;
    throw std::runtime_error ("Singular returned an error ...");
  }
}
void call_singular_and_discard (std::string const& command)
{ 
  SPrintStart();
  call_singular (command);
  char* result_ptr = SPrintEnd();
  omFree (result_ptr);
}
exit;
link l = "ssi:w prime.ssi";
newstruct("token", "list fieldnames, list data");
int i = 7;
token t;
t.fieldnames = list("prime");
t.data = list(i);
write(l,t);
close(l);
exit
;
newstruct("token","list fieldnames, list data");
ring r = 0,(x,y,z),lp;
LIB "random.lib");
LIB "random.lib";
ideal I = randomid(maxideal(30),30);
I;
token t;
l;
link l = "ssi:w input.ssi";
t.fiednames = list("generators");
t.fieldnames = list("generators");
t.data = list(I);
write(l,t);
close(l);
exit;
newstruct("token","list fieldnames, list data");
link l = "ssi:w prime.ssi";
int i = prime(2147483647);
i;
token t;
t.fieldnames = list("integer");
t.data = list(i);
write(l,t);
close(l);
exit;
newstruct("token","list fieldnames, list data");
LIB "random.lib";
ring r=0,(x,y,z),lp;
ideal I = randomid(maxideal(50),50);
I;
token t;
t.fieldnames = list("generators");
t.data = list(I);
write(l,t);
link l = "ssi:w input.ssi";
write(l,t);
close(l);
exit;
link l = "ssi:r input.ssi";
read(l);
read(l);
read(l);
read(l);
read(l);
read(l);
exit;
