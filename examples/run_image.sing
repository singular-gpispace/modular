LIB "modulargspc.lib";
LIB "random.lib";
LIB "modstd.lib";
LIB "modimage.lib";

configToken gc = configure_gspc();

gc.options.tmpdir = "temp";
gc.options.nodefile = "nodefile";
gc.options.procspernode = 4;
gc.options.loghostfile = "loghostfile";
gc.options.logport = 9876;

configToken pc = configure_modular();

pc.options.library = "modularImage.lib";
pc.options.procCompute = "ImageRationalMap";
pc.options.procLift = "liftt";
pc.options.procReconstest = "reconstest";
pc.options.bal1 = 4;
pc.options.bal2 = 8;

generateIOTokenTypes();

ring R = 0,(t0,t1,t2),dp;
//ideal I =  11x7y+3x+1,z4+7;
ideal I = t1^5+10*t1^4*t2+20*t1^3*t2^2+130*t1^2*t2^3-20*t1*t2^4+20*t2^5-2*t1^4*t0-40*t1^3*t2*t0-150*t1^2*t2^2*t0-90*t1*t2^3*t0-40*t2^4*t0+t1^3*t0^2+30*t1^2*t2*t0^2+110*t1*t2^2*t0^2+20*t2^3*t0^2;
I;
ideal phi = randomid(maxideal(2),8);
phi;

token input;
input.fieldnames = list("map","variety");
input.data[1] = phi;
input.data[2] = I;
list l = list(input);
int num_primes = 2000;

intvec primeiv = primeList(I, num_primes);
int i;
list primelists;

token t;
for (i = 1; i <= num_primes; i++)
{
  t.fieldnames = list("int");
  t.data = list(primeiv[i]);
	primelists[i] = t;
}
def re = gspc_modular(l,primelists, gc, pc);
def r = re.r_data;
setring r;
re.data[1];
